"""Contains classes for evaluating the performance of the models."""

from pathlib import Path
import pandas as pd
import yaml
from typing import TypeVar, List
from utils.logger import Logger
import copy
from PIL import Image
import traceback
from utils.files import validate_path

logger = Logger(__name__)

from evaluation.models.openai import OpenAI
from evaluation.models.deepmind import DeepMind
from evaluation.models.messages.message import UserMessage, SystemMessage, AssistantMessage, ImageMessage, BaseMessage

Messages = TypeVar("Messages", UserMessage, SystemMessage, AssistantMessage, ImageMessage, BaseMessage)

Model = TypeVar('Model', OpenAI, DeepMind)

class Evaluator:
  """
  Evaluator for the models.
  
  Attributes
  ----------
  dataframe : pd.DataFrame
      the DataFrame for the evaluation
  columns : list
      the columns for the DataFrame
  """
  columns: list = ['n_generation', 'n_variation', 'n_format', 'structure', 'text_task', 'text_prompt', 'image_prompt', 'model_response', 'expected_response', 'match', 'node_font', 'node_color', 'edge_width', 'task_id']
  
  def evaluate(self, model: Model, messages: List[Messages], yaml_path: Path, yaml_name: str, csv_path: Path, csv_name: str, limit: int = None) -> None:
    """
    Evaluates the model.
    
    Parameters
    ----------
    model : Model
        the model to evaluate
    messages : List[Messages]
        the messages to evaluate
    limit : int (optional = None)
        the limit for the evaluation
    yaml_path : Path
        the path to the evaluation YAML file
    yaml_name : str
        the name of the evaluation YAML file
    csv_path : Path
        the path to the results CSV file
    csv_name : str
        the name of the results CSV file
        
    Raises
    ------
    FileNotFoundError
        if the YAML file is not found
    pd.errors.EmptyDataError
        if the CSV file is empty
        
    Notes
    -----
    The evaluation YAML file has a default format for evaluation. This format is generated by the `BatchGenerator` and is as follows:
    
    ```yaml
    - color: '#88d7fe'
      expected: '[30, 71, 56, 69, 42, 19, 25]'
      font: serif
      format: 2
      generation: 1
      id: eab69c75-2644-496b-806e-fb6daa36347a
      image_path: images/binary_tree/bit_run-2_gen-1_var-1_fmt-2_thk-05_clr-88d7fe_fnt-serif_idn-eab69c75-2644-496b-806e-fb6daa36347a.png
      structure: binary_tree
      text: Provide a single-line python list representing the post-order traversal of
        the binary tree.
      width: '0.5'
      variation: 1
    ```
    """
    
    save_path = validate_path(csv_path, csv_name, '.csv')
    file_exists = save_path.is_file()
    
    with open(validate_path(yaml_path, yaml_name, '.yaml'), 'r') as file:
      prompts = yaml.safe_load(file) or []

    # Check if the file exists, if not, create a new one with headers
    try:
      self.dataframe = pd.read_csv(save_path)
    except (FileNotFoundError, pd.errors.EmptyDataError):
      logger.info(f'Creating new CSV at {save_path}')
      self.dataframe = pd.DataFrame(columns=self.columns)
      self.dataframe.to_csv(save_path, index=False)

    for i, prompt in enumerate(prompts):
      message_list = copy.deepcopy(messages)
      
      if limit is not None and i >= limit:
        break
      else:
        try:
          image_path = Path(prompt.get('image_path'))
          
          for message in message_list:
              if hasattr(message, 'content'):
                if "{{content}}" in message.content:
                  message.content = message.content.replace("{{content}}", prompt.get('text'))
              if hasattr(message, 'images'):
                  images = []
                  for image in message.images:
                      if image == "{{image}}":
                          image = image_path
                      images.append(image)
                  message.images = images
              elif hasattr(message, 'image'):
                  if message.image == "{{image}}":
                      message.image = Image.open(image_path)
                      
          content = model.run(message_list)
          
          if prompt.get('expected').strip("][}{") in content:
            match = True
          else:
            match = False

          # Append new data to the DataFrame
          new_row = {
            'n_generation': prompt.get('generation'),
            'n_variation': prompt.get('variation'),
            'n_format': prompt.get('format'),
            'structure': prompt.get('structure'),
            'text_task': str(prompt.get('text')),
            'text_prompt': str([message.content for message in message_list if type(message) == UserMessage]).strip("]["),
            'image_prompt': image_path,
            'model_response': content.replace('\n', '\\n'),
            'expected_response': prompt.get('expected'),
            'match': match,
            'node_font': prompt.get('font'),
            'node_color': prompt.get('color'),
            'edge_width': prompt.get('width'),
            'task_id': prompt.get('id'),
          }
          
          pd.DataFrame([new_row]).to_csv(save_path, mode='a', header=not file_exists, index=False)
          file_exists = True  # After the first write, header should not be written again.

        except Exception as e:
            tb = traceback.format_exc()
            logger.error(f'{type(e).__name__} @ {__name__}: {e}\n{tb}')
            return